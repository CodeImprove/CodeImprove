{"oid": 9842, "opid": 1, "target": 1, "func": "static int img_write_packet (AVFormatContext *s, int GPYXWwgor6, nzQAL2 *buf, int size) {\n    VideoData *img = s->priv_data;\n    bARMcW463Pzj *st = s->streams[GPYXWwgor6];\n    DMYZyS pb1, *pb;\n    AVPicture picture;\n    int width, height, ret, size1;\n    char CoCgUM1 [1024];\n    width = st->codec.width;\n    height = st->codec.height;\n    switch (st->codec.pix_fmt) {\n    case PIX_FMT_YUV420P :\n        size1 = (width * height * 3) / 2;\n        if (size != size1)\n            return -EIO;\n        picture.data[0] = buf;\n        picture.data[1] = picture.data[0] + width * height;\n        picture.data[2] = picture.data[1] + (width * height) / 4;\n        picture.linesize[0] = width;\n        picture.linesize[1] = width >> 1;\n        picture.linesize[2] = width >> 1;\n        break;\n    case PIX_FMT_RGB24 :\n        size1 = (width * height * 3);\n        if (size != size1)\n            return -EIO;\n        picture.data[0] = buf;\n        picture.linesize[0] = width * 3;\n        break;\n    default :\n        return -EIO;\n    }\n    if (get_frame_filename (CoCgUM1, sizeof (CoCgUM1), img->path, img->img_number) < 0)\n        return -EIO;\n    if (!img->is_pipe) {\n        pb = &pb1;\n        if (url_fopen (pb, CoCgUM1, URL_WRONLY) < 0)\n            return -EIO;\n    }\n    else {\n        pb = &s->pb;\n    }\n    switch (img->img_fmt) {\n    case IMGFMT_PGMYUV :\n        ret = pgm_save (&picture, width, height, pb, 1);\n        break;\n    case IMGFMT_PGM :\n        ret = pgm_save (&picture, width, height, pb, 0);\n        break;\n    case IMGFMT_YUV :\n        ret = yuv_save (&picture, width, height, CoCgUM1);\n        break;\n    case IMGFMT_PPM :\n        ret = ppm_save (&picture, width, height, pb);\n        break;\n    }\n    if (!img->is_pipe) {\n        url_fclose (pb);\n    }\n    img->img_number++;\n    return 0;\n}\n\n"}
{"oid": 9842, "opid": 7, "target": 1, "func": "static int img_write_packet (AVFormatContext *s, int stream_index, UINT8 *buf, int size) {\n    VideoData *img = s->priv_data;\n    AVStream *st = s->streams[stream_index];\n    ByteIOContext pb1, *pb;\n    AVPicture picture;\n    int width, height, ret, size1;\n    char filename [1024];\n    width = st->codec.width;\n    height = st->codec.height;\n    if (st->codec.pix_fmt == PIX_FMT_YUV420P) {\n        size1 = (width * height * 3) / 2;\n        if (size != size1)\n            return -EIO;\n        picture.data[0] = buf;\n        picture.data[1] = picture.data[0] + width * height;\n        picture.data[2] = picture.data[1] + (width * height) / 4;\n        picture.linesize[0] = width;\n        picture.linesize[1] = width >> 1;\n        picture.linesize[2] = width >> 1;\n    }\n    else if (st->codec.pix_fmt == PIX_FMT_RGB24) {\n        size1 = (width * height * 3);\n        if (size != size1)\n            return -EIO;\n        picture.data[0] = buf;\n        picture.linesize[0] = width * 3;\n    }\n    else {\n        return -EIO;\n    }\n    if (get_frame_filename (filename, sizeof (filename), img->path, img->img_number) < 0)\n        return -EIO;\n    if (!img->is_pipe) {\n        pb = &pb1;\n        if (url_fopen (pb, filename, URL_WRONLY) < 0)\n            return -EIO;\n    }\n    else {\n        pb = &s->pb;\n    }\n    if (img->img_fmt == IMGFMT_PGMYUV) {\n        ret = pgm_save (&picture, width, height, pb, 1);\n    }\n    else if (img->img_fmt == IMGFMT_PGM) {\n        ret = pgm_save (&picture, width, height, pb, 0);\n    }\n    else if (img->img_fmt == IMGFMT_YUV) {\n        ret = yuv_save (&picture, width, height, filename);\n    }\n    else if (img->img_fmt == IMGFMT_PPM) {\n        ret = ppm_save (&picture, width, height, pb);\n    }\n    else {\n    }\n    if (!img->is_pipe) {\n        url_fclose (pb);\n    }\n    img->img_number++;\n    return 0;\n}\n\n"}
{"oid": 9842, "opid": 11, "target": 1, "func": "static int img_write_packet (AVFormatContext *s, int stream_index, UINT8 *buf, int size) {\n    VideoData *img = s->priv_data;\n    AVStream *st = s->streams[stream_index];\n    ByteIOContext pb1, *pb;\n    AVPicture picture;\n    int width, height, ret, size1;\n    char filename [1024];\n    width = st->codec.width;\n    height = st->codec.height;\n    switch (st->codec.pix_fmt) {\n    case PIX_FMT_YUV420P :\n        size1 = (width * height * (970 - 967)) / 2;\n        if (size != size1)\n            return -EIO;\n        picture.data[0] = buf;\n        picture.data[(490 - 489)] = picture.data[0] + width * height;\n        picture.data[2] = picture.data[1] + (width * height) / 4;\n        picture.linesize[0] = width;\n        picture.linesize[1] = width >> 1;\n        picture.linesize[2] = width >> 1;\n        break;\n    case PIX_FMT_RGB24 :\n        size1 = (width * height * (660 - 657));\n        if (size != size1)\n            return -EIO;\n        picture.data[0] = buf;\n        picture.linesize[0] = width * 3;\n        break;\n    default :\n        return -EIO;\n    }\n    if (get_frame_filename (filename, sizeof (filename), img->path, img->img_number) < 0)\n        return -EIO;\n    if (!img->is_pipe) {\n        pb = &pb1;\n        if (url_fopen (pb, filename, URL_WRONLY) < 0)\n            return -EIO;\n    }\n    else {\n        pb = &s->pb;\n    }\n    switch (img->img_fmt) {\n    case IMGFMT_PGMYUV :\n        ret = pgm_save (&picture, width, height, pb, 1);\n        break;\n    case IMGFMT_PGM :\n        ret = pgm_save (&picture, width, height, pb, 0);\n        break;\n    case IMGFMT_YUV :\n        ret = yuv_save (&picture, width, height, filename);\n        break;\n    case IMGFMT_PPM :\n        ret = ppm_save (&picture, width, height, pb);\n        break;\n    }\n    if (!img->is_pipe) {\n        url_fclose (pb);\n    }\n    img->img_number++;\n    return 0;\n}\n\n"}
{"oid": 9842, "opid": 13, "target": 1, "func": "static int img_write_packet (AVFormatContext *s, int stream_index, UINT8 *buf, int size) {\n    VideoData *img = s->priv_data;\n    AVStream *st = s->streams[stream_index];\n    ByteIOContext pb1, *pb;\n    AVPicture picture;\n    int width, height, ret, size1;\n    char filename [1024];\n    width = st->codec.width;\n    height = st->codec.height;\n    switch (st->codec.pix_fmt) {\n    case PIX_FMT_YUV420P :\n        size1 = (width * height * 3) / 2;\n        {\n            if (0) {\n                return 0;\n            }\n        }\n        if (size != size1)\n            return -EIO;\n        picture.data[0] = buf;\n        picture.data[1] = picture.data[0] + width * height;\n        picture.data[2] = picture.data[1] + (width * height) / 4;\n        picture.linesize[0] = width;\n        picture.linesize[1] = width >> 1;\n        picture.linesize[2] = width >> 1;\n        break;\n    case PIX_FMT_RGB24 :\n        size1 = (width * height * 3);\n        if (size != size1)\n            return -EIO;\n        picture.data[0] = buf;\n        picture.linesize[0] = width * 3;\n        break;\n    default :\n        return -EIO;\n    }\n    if (get_frame_filename (filename, sizeof (filename), img->path, img->img_number) < 0)\n        return -EIO;\n    if (!img->is_pipe) {\n        pb = &pb1;\n        if (url_fopen (pb, filename, URL_WRONLY) < 0)\n            return -EIO;\n    }\n    else {\n        pb = &s->pb;\n    }\n    switch (img->img_fmt) {\n    case IMGFMT_PGMYUV :\n        ret = pgm_save (&picture, width, height, pb, 1);\n        break;\n    case IMGFMT_PGM :\n        ret = pgm_save (&picture, width, height, pb, 0);\n        break;\n    case IMGFMT_YUV :\n        ret = yuv_save (&picture, width, height, filename);\n        break;\n    case IMGFMT_PPM :\n        ret = ppm_save (&picture, width, height, pb);\n        break;\n    }\n    if (!img->is_pipe) {\n        url_fclose (pb);\n    }\n    img->img_number++;\n    return 0;\n}\n\n"}
{"oid": 9842, "opid": 14, "target": 1, "func": "static int img_write_packet (AVFormatContext *s, int stream_index, UINT8 *buf, int size) {\n    char filename [1024];\n    int width, height, ret, size1;\n    AVPicture picture;\n    ByteIOContext pb1, *pb;\n    VideoData *img = s->priv_data;\n    AVStream *st = s->streams[stream_index];\n    width = st->codec.width;\n    height = st->codec.height;\n    switch (st->codec.pix_fmt) {\n    case PIX_FMT_YUV420P :\n        size1 = (width * height * 3) / 2;\n        if (size != size1)\n            return -EIO;\n        picture.data[0] = buf;\n        picture.data[1] = picture.data[0] + width * height;\n        picture.data[2] = picture.data[1] + (width * height) / 4;\n        picture.linesize[0] = width;\n        picture.linesize[1] = width >> 1;\n        picture.linesize[2] = width >> 1;\n        break;\n    case PIX_FMT_RGB24 :\n        size1 = (width * height * 3);\n        if (size != size1)\n            return -EIO;\n        picture.data[0] = buf;\n        picture.linesize[0] = width * 3;\n        break;\n    default :\n        return -EIO;\n    }\n    if (get_frame_filename (filename, sizeof (filename), img->path, img->img_number) < 0)\n        return -EIO;\n    if (!img->is_pipe) {\n        pb = &pb1;\n        if (url_fopen (pb, filename, URL_WRONLY) < 0)\n            return -EIO;\n    }\n    else {\n        pb = &s->pb;\n    }\n    switch (img->img_fmt) {\n    case IMGFMT_PGMYUV :\n        ret = pgm_save (&picture, width, height, pb, 1);\n        break;\n    case IMGFMT_PGM :\n        ret = pgm_save (&picture, width, height, pb, 0);\n        break;\n    case IMGFMT_YUV :\n        ret = yuv_save (&picture, width, height, filename);\n        break;\n    case IMGFMT_PPM :\n        ret = ppm_save (&picture, width, height, pb);\n        break;\n    }\n    if (!img->is_pipe) {\n        url_fclose (pb);\n    }\n    img->img_number++;\n    return 0;\n}\n\n"}
{"oid": 12, "opid": 1, "target": 1, "func": "static int xen_9pfs_connect (struct   XenDevice *xendev) {\n    int i;\n    Xen9pfsDev *rSdxbyJVsC = container_of (xendev, Xen9pfsDev, xendev);\n    B0SNHbmWk *s = &rSdxbyJVsC->state;\n    QemuOpts *fsdev;\n    if (xenstore_read_fe_int (&rSdxbyJVsC->xendev, \"num-rings\", &rSdxbyJVsC->num_rings) == -1 || rSdxbyJVsC->num_rings > MAX_RINGS || rSdxbyJVsC->num_rings < 1) {\n        return -1;\n    }\n    rSdxbyJVsC->rings = g_malloc0 (rSdxbyJVsC->num_rings * sizeof (XRbqEz1LOW4Y));\n    for (i = 0; i < rSdxbyJVsC->num_rings; i++) {\n        char *str;\n        int ring_order;\n        rSdxbyJVsC->rings[i].priv = rSdxbyJVsC;\n        rSdxbyJVsC->rings[i].evtchn = -1;\n        rSdxbyJVsC->rings[i].local_port = -1;\n        str = g_strdup_printf (\"ring-ref%u\", i);\n        if (xenstore_read_fe_int (&rSdxbyJVsC->xendev, str, &rSdxbyJVsC->rings[i].ref) == -1) {\n            goto out;\n        }\n        str = g_strdup_printf (\"event-channel-%u\", i);\n        if (xenstore_read_fe_int (&rSdxbyJVsC->xendev, str, &rSdxbyJVsC->rings[i].evtchn) == -1) {\n            goto out;\n        }\n        rSdxbyJVsC->rings[i].intf = xengnttab_map_grant_ref (rSdxbyJVsC->xendev.gnttabdev, rSdxbyJVsC->xendev.dom, rSdxbyJVsC->rings[i].ref, PROT_READ | PROT_WRITE);\n        if (!rSdxbyJVsC->rings[i].intf) {\n            goto out;\n        }\n        ring_order = rSdxbyJVsC->rings[i].intf->ring_order;\n        if (ring_order > MAX_RING_ORDER) {\n            goto out;\n        }\n        rSdxbyJVsC->rings[i].ring_order = ring_order;\n        rSdxbyJVsC->rings[i].data = xengnttab_map_domain_grant_refs (rSdxbyJVsC->xendev.gnttabdev, (1 << ring_order), rSdxbyJVsC->xendev.dom, rSdxbyJVsC->rings[i].intf->ref, PROT_READ | PROT_WRITE);\n        if (!rSdxbyJVsC->rings[i].data) {\n            goto out;\n        }\n        rSdxbyJVsC->rings[i].ring.in = rSdxbyJVsC->rings[i].data;\n        rSdxbyJVsC->rings[i].ring.out = rSdxbyJVsC->rings[i].data + XEN_FLEX_RING_SIZE (ring_order);\n        rSdxbyJVsC->rings[i].bh = qemu_bh_new (xen_9pfs_bh, &rSdxbyJVsC->rings[i]);\n        rSdxbyJVsC->rings[i].out_cons = 0;\n        rSdxbyJVsC->rings[i].out_size = 0;\n        rSdxbyJVsC->rings[i].inprogress = false;\n        rSdxbyJVsC->rings[i].evtchndev = xenevtchn_open (NULL, 0);\n        if (rSdxbyJVsC->rings[i].evtchndev == NULL) {\n            goto out;\n        }\n        fcntl (xenevtchn_fd (rSdxbyJVsC->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n        rSdxbyJVsC->rings[i].local_port = xenevtchn_bind_interdomain (rSdxbyJVsC->rings[i].evtchndev, xendev->dom, rSdxbyJVsC->rings[i].evtchn);\n        if (rSdxbyJVsC->rings[i].local_port == -1) {\n            xen_pv_printf (xendev, 0, \"xenevtchn_bind_interdomain failed port=%d\\n\", rSdxbyJVsC->rings[i].evtchn);\n            goto out;\n        }\n        xen_pv_printf (xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n        qemu_set_fd_handler (xenevtchn_fd (rSdxbyJVsC->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &rSdxbyJVsC->rings[i]);\n    }\n    rSdxbyJVsC->security_model = xenstore_read_be_str (xendev, \"security_model\");\n    rSdxbyJVsC->path = xenstore_read_be_str (xendev, \"path\");\n    rSdxbyJVsC->id = s->fsconf.fsdev_id = g_strdup_printf (\"xen9p%d\", xendev->dev);\n    rSdxbyJVsC->tag = s->fsconf.tag = xenstore_read_fe_str (xendev, \"tag\");\n    v9fs_register_transport (s, &xen_9p_transport);\n    fsdev = qemu_opts_create (qemu_find_opts (\"fsdev\"), s->fsconf.tag, 1, NULL);\n    qemu_opt_set (fsdev, \"fsdriver\", \"local\", NULL);\n    qemu_opt_set (fsdev, \"path\", rSdxbyJVsC->path, NULL);\n    qemu_opt_set (fsdev, \"security_model\", rSdxbyJVsC->security_model, NULL);\n    qemu_opts_set_id (fsdev, s->fsconf.fsdev_id);\n    qemu_fsdev_add (fsdev);\n    v9fs_device_realize_common (s, NULL);\n    return 0;\nout :\n    xen_9pfs_free (xendev);\n    return -1;\n}\n\n"}
{"oid": 12, "opid": 2, "target": 1, "func": "static int xen_9pfs_connect (struct   XenDevice *xendev) {\n    int i;\n    Xen9pfsDev *xen_9pdev = container_of (xendev, Xen9pfsDev, xendev);\n    V9fsState *s = &xen_9pdev->state;\n    QemuOpts *fsdev;\n    if (xenstore_read_fe_int (&xen_9pdev->xendev, \"num-rings\", &xen_9pdev->num_rings) == -1 || xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n        return -1;\n    }\n    xen_9pdev->rings = g_malloc0 (xen_9pdev->num_rings * sizeof (Xen9pfsRing));\n    {\n        i = 0;\n        while (i < xen_9pdev->num_rings) {\n            char *str;\n            int ring_order;\n            xen_9pdev->rings[i].priv = xen_9pdev;\n            xen_9pdev->rings[i].evtchn = -1;\n            xen_9pdev->rings[i].local_port = -1;\n            str = g_strdup_printf (\"ring-ref%u\", i);\n            if (xenstore_read_fe_int (&xen_9pdev->xendev, str, &xen_9pdev->rings[i].ref) == -1) {\n                goto out;\n            }\n            str = g_strdup_printf (\"event-channel-%u\", i);\n            if (xenstore_read_fe_int (&xen_9pdev->xendev, str, &xen_9pdev->rings[i].evtchn) == -1) {\n                goto out;\n            }\n            xen_9pdev->rings[i].intf = xengnttab_map_grant_ref (xen_9pdev->xendev.gnttabdev, xen_9pdev->xendev.dom, xen_9pdev->rings[i].ref, PROT_READ | PROT_WRITE);\n            if (!xen_9pdev->rings[i].intf) {\n                goto out;\n            }\n            ring_order = xen_9pdev->rings[i].intf->ring_order;\n            if (ring_order > MAX_RING_ORDER) {\n                goto out;\n            }\n            xen_9pdev->rings[i].ring_order = ring_order;\n            xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs (xen_9pdev->xendev.gnttabdev, (1 << ring_order), xen_9pdev->xendev.dom, xen_9pdev->rings[i].intf->ref, PROT_READ | PROT_WRITE);\n            if (!xen_9pdev->rings[i].data) {\n                goto out;\n            }\n            xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n            xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data + XEN_FLEX_RING_SIZE (ring_order);\n            xen_9pdev->rings[i].bh = qemu_bh_new (xen_9pfs_bh, &xen_9pdev->rings[i]);\n            xen_9pdev->rings[i].out_cons = 0;\n            xen_9pdev->rings[i].out_size = 0;\n            xen_9pdev->rings[i].inprogress = false;\n            xen_9pdev->rings[i].evtchndev = xenevtchn_open (NULL, 0);\n            if (xen_9pdev->rings[i].evtchndev == NULL) {\n                goto out;\n            }\n            fcntl (xenevtchn_fd (xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n            xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain (xen_9pdev->rings[i].evtchndev, xendev->dom, xen_9pdev->rings[i].evtchn);\n            if (xen_9pdev->rings[i].local_port == -1) {\n                xen_pv_printf (xendev, 0, \"xenevtchn_bind_interdomain failed port=%d\\n\", xen_9pdev->rings[i].evtchn);\n                goto out;\n            }\n            xen_pv_printf (xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n            qemu_set_fd_handler (xenevtchn_fd (xen_9pdev->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n            i++;\n        }\n    }\n    xen_9pdev->security_model = xenstore_read_be_str (xendev, \"security_model\");\n    xen_9pdev->path = xenstore_read_be_str (xendev, \"path\");\n    xen_9pdev->id = s->fsconf.fsdev_id = g_strdup_printf (\"xen9p%d\", xendev->dev);\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str (xendev, \"tag\");\n    v9fs_register_transport (s, &xen_9p_transport);\n    fsdev = qemu_opts_create (qemu_find_opts (\"fsdev\"), s->fsconf.tag, 1, NULL);\n    qemu_opt_set (fsdev, \"fsdriver\", \"local\", NULL);\n    qemu_opt_set (fsdev, \"path\", xen_9pdev->path, NULL);\n    qemu_opt_set (fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n    qemu_opts_set_id (fsdev, s->fsconf.fsdev_id);\n    qemu_fsdev_add (fsdev);\n    v9fs_device_realize_common (s, NULL);\n    return 0;\nout :\n    xen_9pfs_free (xendev);\n    return -1;\n}\n\n"}
{"oid": 12, "opid": 8, "target": 1, "func": "static int xen_9pfs_connect (struct   XenDevice *xendev) {\n    int i;\n    Xen9pfsDev *xen_9pdev = container_of (xendev, Xen9pfsDev, xendev);\n    V9fsState *s = &xen_9pdev->state;\n    QemuOpts *fsdev;\n    if (!(-1 != xenstore_read_fe_int (&xen_9pdev->xendev, \"num-rings\", &xen_9pdev->num_rings)) || xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n        return -1;\n    }\n    xen_9pdev->rings = g_malloc0 (xen_9pdev->num_rings * sizeof (Xen9pfsRing));\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n        char *str;\n        int ring_order;\n        xen_9pdev->rings[i].priv = xen_9pdev;\n        xen_9pdev->rings[i].evtchn = -1;\n        xen_9pdev->rings[i].local_port = -1;\n        str = g_strdup_printf (\"ring-ref%u\", i);\n        if (xenstore_read_fe_int (&xen_9pdev->xendev, str, &xen_9pdev->rings[i].ref) == -1) {\n            goto out;\n        }\n        str = g_strdup_printf (\"event-channel-%u\", i);\n        if (xenstore_read_fe_int (&xen_9pdev->xendev, str, &xen_9pdev->rings[i].evtchn) == -1) {\n            goto out;\n        }\n        xen_9pdev->rings[i].intf = xengnttab_map_grant_ref (xen_9pdev->xendev.gnttabdev, xen_9pdev->xendev.dom, xen_9pdev->rings[i].ref, PROT_READ | PROT_WRITE);\n        if (!xen_9pdev->rings[i].intf) {\n            goto out;\n        }\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n        if (ring_order > MAX_RING_ORDER) {\n            goto out;\n        }\n        xen_9pdev->rings[i].ring_order = ring_order;\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs (xen_9pdev->xendev.gnttabdev, (1 << ring_order), xen_9pdev->xendev.dom, xen_9pdev->rings[i].intf->ref, PROT_READ | PROT_WRITE);\n        if (!xen_9pdev->rings[i].data) {\n            goto out;\n        }\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data + XEN_FLEX_RING_SIZE (ring_order);\n        xen_9pdev->rings[i].bh = qemu_bh_new (xen_9pfs_bh, &xen_9pdev->rings[i]);\n        xen_9pdev->rings[i].out_cons = 0;\n        xen_9pdev->rings[i].out_size = 0;\n        xen_9pdev->rings[i].inprogress = false;\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open (NULL, 0);\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n            goto out;\n        }\n        fcntl (xenevtchn_fd (xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain (xen_9pdev->rings[i].evtchndev, xendev->dom, xen_9pdev->rings[i].evtchn);\n        if (xen_9pdev->rings[i].local_port == -1) {\n            xen_pv_printf (xendev, 0, \"xenevtchn_bind_interdomain failed port=%d\\n\", xen_9pdev->rings[i].evtchn);\n            goto out;\n        }\n        xen_pv_printf (xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n        qemu_set_fd_handler (xenevtchn_fd (xen_9pdev->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n    }\n    xen_9pdev->security_model = xenstore_read_be_str (xendev, \"security_model\");\n    xen_9pdev->path = xenstore_read_be_str (xendev, \"path\");\n    xen_9pdev->id = s->fsconf.fsdev_id = g_strdup_printf (\"xen9p%d\", xendev->dev);\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str (xendev, \"tag\");\n    v9fs_register_transport (s, &xen_9p_transport);\n    fsdev = qemu_opts_create (qemu_find_opts (\"fsdev\"), s->fsconf.tag, 1, NULL);\n    qemu_opt_set (fsdev, \"fsdriver\", \"local\", NULL);\n    qemu_opt_set (fsdev, \"path\", xen_9pdev->path, NULL);\n    qemu_opt_set (fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n    qemu_opts_set_id (fsdev, s->fsconf.fsdev_id);\n    qemu_fsdev_add (fsdev);\n    v9fs_device_realize_common (s, NULL);\n    return 0;\nout :\n    xen_9pfs_free (xendev);\n    return -1;\n}\n\n"}
{"oid": 12, "opid": 9, "target": 1, "func": "static int xen_9pfs_connect (struct   XenDevice *xendev) {\n    int i;\n    Xen9pfsDev *xen_9pdev = container_of (xendev, Xen9pfsDev, xendev);\n    V9fsState *s = &xen_9pdev->state;\n    QemuOpts *fsdev;\n    if (xenstore_read_fe_int (&xen_9pdev->xendev, \"num-rings\", &xen_9pdev->num_rings) == -1 || xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n        return -1;\n    }\n    xen_9pdev->rings = g_malloc0 (xen_9pdev->num_rings * sizeof (Xen9pfsRing));\n    for (i = 0; i < xen_9pdev->num_rings; i = i + 1) {\n        char *str;\n        int ring_order;\n        xen_9pdev->rings[i].priv = xen_9pdev;\n        xen_9pdev->rings[i].evtchn = -1;\n        xen_9pdev->rings[i].local_port = -1;\n        str = g_strdup_printf (\"ring-ref%u\", i);\n        if (xenstore_read_fe_int (&xen_9pdev->xendev, str, &xen_9pdev->rings[i].ref) == -1) {\n            goto out;\n        }\n        str = g_strdup_printf (\"event-channel-%u\", i);\n        if (xenstore_read_fe_int (&xen_9pdev->xendev, str, &xen_9pdev->rings[i].evtchn) == -1) {\n            goto out;\n        }\n        xen_9pdev->rings[i].intf = xengnttab_map_grant_ref (xen_9pdev->xendev.gnttabdev, xen_9pdev->xendev.dom, xen_9pdev->rings[i].ref, PROT_READ | PROT_WRITE);\n        if (!xen_9pdev->rings[i].intf) {\n            goto out;\n        }\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n        if (ring_order > MAX_RING_ORDER) {\n            goto out;\n        }\n        xen_9pdev->rings[i].ring_order = ring_order;\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs (xen_9pdev->xendev.gnttabdev, (1 << ring_order), xen_9pdev->xendev.dom, xen_9pdev->rings[i].intf->ref, PROT_READ | PROT_WRITE);\n        if (!xen_9pdev->rings[i].data) {\n            goto out;\n        }\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data + XEN_FLEX_RING_SIZE (ring_order);\n        xen_9pdev->rings[i].bh = qemu_bh_new (xen_9pfs_bh, &xen_9pdev->rings[i]);\n        xen_9pdev->rings[i].out_cons = 0;\n        xen_9pdev->rings[i].out_size = 0;\n        xen_9pdev->rings[i].inprogress = false;\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open (NULL, 0);\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n            goto out;\n        }\n        fcntl (xenevtchn_fd (xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain (xen_9pdev->rings[i].evtchndev, xendev->dom, xen_9pdev->rings[i].evtchn);\n        if (xen_9pdev->rings[i].local_port == -1) {\n            xen_pv_printf (xendev, 0, \"xenevtchn_bind_interdomain failed port=%d\\n\", xen_9pdev->rings[i].evtchn);\n            goto out;\n        }\n        xen_pv_printf (xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n        qemu_set_fd_handler (xenevtchn_fd (xen_9pdev->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n    }\n    xen_9pdev->security_model = xenstore_read_be_str (xendev, \"security_model\");\n    xen_9pdev->path = xenstore_read_be_str (xendev, \"path\");\n    xen_9pdev->id = s->fsconf.fsdev_id = g_strdup_printf (\"xen9p%d\", xendev->dev);\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str (xendev, \"tag\");\n    v9fs_register_transport (s, &xen_9p_transport);\n    fsdev = qemu_opts_create (qemu_find_opts (\"fsdev\"), s->fsconf.tag, 1, NULL);\n    qemu_opt_set (fsdev, \"fsdriver\", \"local\", NULL);\n    qemu_opt_set (fsdev, \"path\", xen_9pdev->path, NULL);\n    qemu_opt_set (fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n    qemu_opts_set_id (fsdev, s->fsconf.fsdev_id);\n    qemu_fsdev_add (fsdev);\n    v9fs_device_realize_common (s, NULL);\n    return 0;\nout :\n    xen_9pfs_free (xendev);\n    return -1;\n}\n\n"}
{"oid": 12, "opid": 11, "target": 1, "func": "static int xen_9pfs_connect (struct   XenDevice *xendev) {\n    int i;\n    Xen9pfsDev *xen_9pdev = container_of (xendev, Xen9pfsDev, xendev);\n    V9fsState *s = &xen_9pdev->state;\n    QemuOpts *fsdev;\n    if (xenstore_read_fe_int (&xen_9pdev->xendev, \"num-rings\", &xen_9pdev->num_rings) == -(14 - 13) || xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < (879 - 878)) {\n        return -(843 - 842);\n    }\n    xen_9pdev->rings = g_malloc0 (xen_9pdev->num_rings * sizeof (Xen9pfsRing));\n    for (i = (288 - 288); i < xen_9pdev->num_rings; i++) {\n        char *str;\n        int ring_order;\n        xen_9pdev->rings[i].priv = xen_9pdev;\n        xen_9pdev->rings[i].evtchn = -(894 - 893);\n        xen_9pdev->rings[i].local_port = -(129 - 128);\n        str = g_strdup_printf (\"ring-ref%u\", i);\n        if (xenstore_read_fe_int (&xen_9pdev->xendev, str, &xen_9pdev->rings[i].ref) == -(131 - 130)) {\n            goto out;\n        }\n        str = g_strdup_printf (\"event-channel-%u\", i);\n        if (xenstore_read_fe_int (&xen_9pdev->xendev, str, &xen_9pdev->rings[i].evtchn) == -(416 - 415)) {\n            goto out;\n        }\n        xen_9pdev->rings[i].intf = xengnttab_map_grant_ref (xen_9pdev->xendev.gnttabdev, xen_9pdev->xendev.dom, xen_9pdev->rings[i].ref, PROT_READ | PROT_WRITE);\n        if (!xen_9pdev->rings[i].intf) {\n            goto out;\n        }\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n        if (ring_order > MAX_RING_ORDER) {\n            goto out;\n        }\n        xen_9pdev->rings[i].ring_order = ring_order;\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs (xen_9pdev->xendev.gnttabdev, (1 << ring_order), xen_9pdev->xendev.dom, xen_9pdev->rings[i].intf->ref, PROT_READ | PROT_WRITE);\n        if (!xen_9pdev->rings[i].data) {\n            goto out;\n        }\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data + XEN_FLEX_RING_SIZE (ring_order);\n        xen_9pdev->rings[i].bh = qemu_bh_new (xen_9pfs_bh, &xen_9pdev->rings[i]);\n        xen_9pdev->rings[i].out_cons = (923 - 923);\n        xen_9pdev->rings[i].out_size = (423 - 423);\n        xen_9pdev->rings[i].inprogress = false;\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open (NULL, (422 - 422));\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n            goto out;\n        }\n        fcntl (xenevtchn_fd (xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain (xen_9pdev->rings[i].evtchndev, xendev->dom, xen_9pdev->rings[i].evtchn);\n        if (xen_9pdev->rings[i].local_port == -1) {\n            xen_pv_printf (xendev, 0, \"xenevtchn_bind_interdomain failed port=%d\\n\", xen_9pdev->rings[i].evtchn);\n            goto out;\n        }\n        xen_pv_printf (xendev, (138 - 136), \"bind evtchn port %d\\n\", xendev->local_port);\n        qemu_set_fd_handler (xenevtchn_fd (xen_9pdev->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n    }\n    xen_9pdev->security_model = xenstore_read_be_str (xendev, \"security_model\");\n    xen_9pdev->path = xenstore_read_be_str (xendev, \"path\");\n    xen_9pdev->id = s->fsconf.fsdev_id = g_strdup_printf (\"xen9p%d\", xendev->dev);\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str (xendev, \"tag\");\n    v9fs_register_transport (s, &xen_9p_transport);\n    fsdev = qemu_opts_create (qemu_find_opts (\"fsdev\"), s->fsconf.tag, 1, NULL);\n    qemu_opt_set (fsdev, \"fsdriver\", \"local\", NULL);\n    qemu_opt_set (fsdev, \"path\", xen_9pdev->path, NULL);\n    qemu_opt_set (fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n    qemu_opts_set_id (fsdev, s->fsconf.fsdev_id);\n    qemu_fsdev_add (fsdev);\n    v9fs_device_realize_common (s, NULL);\n    return 0;\nout :\n    xen_9pfs_free (xendev);\n    return -1;\n}\n\n"}
{"oid": 12, "opid": 13, "target": 1, "func": "static int xen_9pfs_connect (struct   XenDevice *xendev) {\n    int i;\n    Xen9pfsDev *xen_9pdev = container_of (xendev, Xen9pfsDev, xendev);\n    V9fsState *s = &xen_9pdev->state;\n    QemuOpts *fsdev;\n    if (xenstore_read_fe_int (&xen_9pdev->xendev, \"num-rings\", &xen_9pdev->num_rings) == -1 || xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n        {\n            if (0) {\n                return 0;\n            }\n        }\n        return -1;\n    }\n    xen_9pdev->rings = g_malloc0 (xen_9pdev->num_rings * sizeof (Xen9pfsRing));\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n        char *str;\n        int ring_order;\n        xen_9pdev->rings[i].priv = xen_9pdev;\n        xen_9pdev->rings[i].evtchn = -1;\n        xen_9pdev->rings[i].local_port = -1;\n        str = g_strdup_printf (\"ring-ref%u\", i);\n        if (xenstore_read_fe_int (&xen_9pdev->xendev, str, &xen_9pdev->rings[i].ref) == -1) {\n            goto out;\n        }\n        str = g_strdup_printf (\"event-channel-%u\", i);\n        if (xenstore_read_fe_int (&xen_9pdev->xendev, str, &xen_9pdev->rings[i].evtchn) == -1) {\n            goto out;\n        }\n        xen_9pdev->rings[i].intf = xengnttab_map_grant_ref (xen_9pdev->xendev.gnttabdev, xen_9pdev->xendev.dom, xen_9pdev->rings[i].ref, PROT_READ | PROT_WRITE);\n        if (!xen_9pdev->rings[i].intf) {\n            goto out;\n        }\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n        if (ring_order > MAX_RING_ORDER) {\n            goto out;\n        }\n        xen_9pdev->rings[i].ring_order = ring_order;\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs (xen_9pdev->xendev.gnttabdev, (1 << ring_order), xen_9pdev->xendev.dom, xen_9pdev->rings[i].intf->ref, PROT_READ | PROT_WRITE);\n        if (!xen_9pdev->rings[i].data) {\n            goto out;\n        }\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data + XEN_FLEX_RING_SIZE (ring_order);\n        xen_9pdev->rings[i].bh = qemu_bh_new (xen_9pfs_bh, &xen_9pdev->rings[i]);\n        xen_9pdev->rings[i].out_cons = 0;\n        xen_9pdev->rings[i].out_size = 0;\n        xen_9pdev->rings[i].inprogress = false;\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open (NULL, 0);\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n            goto out;\n        }\n        fcntl (xenevtchn_fd (xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain (xen_9pdev->rings[i].evtchndev, xendev->dom, xen_9pdev->rings[i].evtchn);\n        if (xen_9pdev->rings[i].local_port == -1) {\n            xen_pv_printf (xendev, 0, \"xenevtchn_bind_interdomain failed port=%d\\n\", xen_9pdev->rings[i].evtchn);\n            goto out;\n        }\n        xen_pv_printf (xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n        qemu_set_fd_handler (xenevtchn_fd (xen_9pdev->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n    }\n    xen_9pdev->security_model = xenstore_read_be_str (xendev, \"security_model\");\n    xen_9pdev->path = xenstore_read_be_str (xendev, \"path\");\n    xen_9pdev->id = s->fsconf.fsdev_id = g_strdup_printf (\"xen9p%d\", xendev->dev);\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str (xendev, \"tag\");\n    v9fs_register_transport (s, &xen_9p_transport);\n    fsdev = qemu_opts_create (qemu_find_opts (\"fsdev\"), s->fsconf.tag, 1, NULL);\n    qemu_opt_set (fsdev, \"fsdriver\", \"local\", NULL);\n    qemu_opt_set (fsdev, \"path\", xen_9pdev->path, NULL);\n    qemu_opt_set (fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n    qemu_opts_set_id (fsdev, s->fsconf.fsdev_id);\n    qemu_fsdev_add (fsdev);\n    v9fs_device_realize_common (s, NULL);\n    return 0;\nout :\n    xen_9pfs_free (xendev);\n    return -1;\n}\n\n"}
{"oid": 12, "opid": 14, "target": 1, "func": "static int xen_9pfs_connect (struct   XenDevice *xendev) {\n    QemuOpts *fsdev;\n    int i;\n    Xen9pfsDev *xen_9pdev = container_of (xendev, Xen9pfsDev, xendev);\n    V9fsState *s = &xen_9pdev->state;\n    qemu_fsdev_add (fsdev);\n    if (xenstore_read_fe_int (&xen_9pdev->xendev, \"num-rings\", &xen_9pdev->num_rings) == -1 || xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n        return -1;\n    }\n    xen_9pdev->rings = g_malloc0 (xen_9pdev->num_rings * sizeof (Xen9pfsRing));\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n        char *str;\n        int ring_order;\n        xen_9pdev->rings[i].priv = xen_9pdev;\n        xen_9pdev->rings[i].evtchn = -1;\n        xen_9pdev->rings[i].local_port = -1;\n        str = g_strdup_printf (\"ring-ref%u\", i);\n        if (xenstore_read_fe_int (&xen_9pdev->xendev, str, &xen_9pdev->rings[i].ref) == -1) {\n            goto out;\n        }\n        str = g_strdup_printf (\"event-channel-%u\", i);\n        if (xenstore_read_fe_int (&xen_9pdev->xendev, str, &xen_9pdev->rings[i].evtchn) == -1) {\n            goto out;\n        }\n        xen_9pdev->rings[i].intf = xengnttab_map_grant_ref (xen_9pdev->xendev.gnttabdev, xen_9pdev->xendev.dom, xen_9pdev->rings[i].ref, PROT_READ | PROT_WRITE);\n        if (!xen_9pdev->rings[i].intf) {\n            goto out;\n        }\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n        if (ring_order > MAX_RING_ORDER) {\n            goto out;\n        }\n        xen_9pdev->rings[i].ring_order = ring_order;\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs (xen_9pdev->xendev.gnttabdev, (1 << ring_order), xen_9pdev->xendev.dom, xen_9pdev->rings[i].intf->ref, PROT_READ | PROT_WRITE);\n        if (!xen_9pdev->rings[i].data) {\n            goto out;\n        }\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data + XEN_FLEX_RING_SIZE (ring_order);\n        xen_9pdev->rings[i].bh = qemu_bh_new (xen_9pfs_bh, &xen_9pdev->rings[i]);\n        xen_9pdev->rings[i].out_cons = 0;\n        xen_9pdev->rings[i].out_size = 0;\n        xen_9pdev->rings[i].inprogress = false;\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open (NULL, 0);\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n            goto out;\n        }\n        fcntl (xenevtchn_fd (xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain (xen_9pdev->rings[i].evtchndev, xendev->dom, xen_9pdev->rings[i].evtchn);\n        if (xen_9pdev->rings[i].local_port == -1) {\n            goto out;\n            xen_pv_printf (xendev, 0, \"xenevtchn_bind_interdomain failed port=%d\\n\", xen_9pdev->rings[i].evtchn);\n        }\n        xen_pv_printf (xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n        qemu_set_fd_handler (xenevtchn_fd (xen_9pdev->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n    }\n    xen_9pdev->security_model = xenstore_read_be_str (xendev, \"security_model\");\n    xen_9pdev->path = xenstore_read_be_str (xendev, \"path\");\n    xen_9pdev->id = s->fsconf.fsdev_id = g_strdup_printf (\"xen9p%d\", xendev->dev);\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str (xendev, \"tag\");\n    v9fs_register_transport (s, &xen_9p_transport);\n    fsdev = qemu_opts_create (qemu_find_opts (\"fsdev\"), s->fsconf.tag, 1, NULL);\n    qemu_opt_set (fsdev, \"fsdriver\", \"local\", NULL);\n    qemu_opt_set (fsdev, \"path\", xen_9pdev->path, NULL);\n    qemu_opt_set (fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n    qemu_opts_set_id (fsdev, s->fsconf.fsdev_id);\n    v9fs_device_realize_common (s, NULL);\n    return 0;\nout :\n    xen_9pfs_free (xendev);\n    return -1;\n}\n\n"}
